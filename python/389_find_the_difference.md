# Find the Difference

[[hashtable]] [[string]] [[bit-manipulation]]

## Problem Description

You are given two strings `s` and `t`.

String `t` is generated by random shuffling string `s` and then adding one more letter at a random position.

Return the letter that was added in `t`.

## Examples

**Example 1:**

```text
Input: s = "abcd", t = "abcde"
Output: "e"
Explanation: 'e' is the letter that was added.
```

**Example 2:**

```text
Input: s = "", t = "y"
Output: "y"
```

## Constraints

- `0 <= s.length <= 1000`
- `t.length == s.length + 1`
- `s` and `t` consist of lowercase English letters.

## 解法一：异或运算（最优解）

```python
class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        """
        使用异或运算找出多出的字符
        时间复杂度：O(n)，空间复杂度：O(1)
        """
        result = 0
        
        # 对所有字符的ASCII值进行异或
        for char in s + t:
            result ^= ord(char)
        
        return chr(result)
```

### 算法思路

**异或运算的性质**：

- 相同的数异或结果为0：`a ⊕ a = 0`
- 任何数与0异或等于自身：`a ⊕ 0 = a`
- 异或运算满足交换律和结合律

**核心思想**：

1. 将两个字符串合并
2. 对所有字符的ASCII值进行异或运算
3. 相同的字符会相互抵消（异或为0）
4. 最终结果就是多出的字符

### 算法演示

以 `s = "abc"`, `t = "abcd"` 为例：

```text
合并字符串: "abcabcd"
ASCII值异或:
ord('a') ⊕ ord('b') ⊕ ord('c') ⊕ ord('a') ⊕ ord('b') ⊕ ord('c') ⊕ ord('d')
= (ord('a') ⊕ ord('a')) ⊕ (ord('b') ⊕ ord('b')) ⊕ (ord('c') ⊕ ord('c')) ⊕ ord('d')
= 0 ⊕ 0 ⊕ 0 ⊕ ord('d')
= ord('d')

结果: chr(ord('d')) = 'd'
```

**复杂度分析**：

- 时间复杂度：O(n) - 需要遍历两个字符串
- 空间复杂度：O(1) - 只使用常数额外空间

## 解法二：ASCII值求和

```python
class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        """
        通过ASCII值求和的差值找出多出的字符
        时间复杂度：O(n)，空间复杂度：O(1)
        """
        return chr(sum(ord(char) for char in t) - sum(ord(char) for char in s))
```

### 核心思想

由于字符串t比s多一个字符，两个字符串ASCII值总和的差值就是多出字符的ASCII值。

**复杂度分析**：

- 时间复杂度：O(n) - 需要计算两个字符串的ASCII值总和
- 空间复杂度：O(1) - 只使用常数额外空间

## 解法三：Counter差集

```python
class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        """
        使用Counter计算字符频率差
        时间复杂度：O(n)，空间复杂度：O(1)
        """
        from collections import Counter
        
        diff = Counter(t) - Counter(s)
        return list(diff.keys())[0]
```

### 更简洁的写法

```python
class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        """
        使用Counter的popitem方法
        """
        from collections import Counter
        
        return (Counter(t) - Counter(s)).popitem()[0]
```

**复杂度分析**：

- 时间复杂度：O(n) - 创建Counter需要遍历字符串
- 空间复杂度：O(1) - 只存储不同的字符（最多26个）

## 解法四：奇偶性检查

```python
class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        """
        合并字符串，检查字符出现次数的奇偶性
        时间复杂度：O(n)，空间复杂度：O(1)
        """
        from collections import Counter
        
        counter = Counter(s + t)
        for char, count in counter.items():
            if count % 2 == 1:  # 出现奇数次的字符就是答案
                return char
```

### 算法原理

在合并后的字符串中，除了多出的字符外，其他字符都出现偶数次。因此找出现奇数次的字符即可。

**复杂度分析**：

- 时间复杂度：O(n) - 遍历合并字符串和计数字典
- 空间复杂度：O(1) - 最多存储26个字符的计数

## 解法五：集合差异

```python
class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        """
        利用集合的差异操作
        """
        from collections import Counter
        
        s_counter, t_counter = Counter(s), Counter(t)
        return (set(s_counter.items()) ^ set(t_counter.items())).pop()[0]
```

**复杂度分析**：

- 时间复杂度：O(n) - 创建Counter和集合操作
- 空间复杂度：O(1) - 最多存储26个字符的信息

## 算法对比

| 解法 | 时间复杂度 | 空间复杂度 | 特点 |
|------|------------|------------|------|
| 异或运算 | O(n) | O(1) | 最优解，利用位运算特性 |
| ASCII求和 | O(n) | O(1) | 简洁直观 |
| Counter差集 | O(n) | O(1) | 代码简洁，库函数强大 |
| 奇偶性检查 | O(n) | O(1) | 思路巧妙 |
| 集合差异 | O(n) | O(1) | 展示集合操作 |

## 边界情况处理

1. **空字符串s**：t只有一个字符，直接返回
2. **单字符差异**：所有方法都能正确处理
3. **长字符串**：算法效率保持稳定

## 关键要点

1. **异或运算的妙用**：利用异或运算的数学性质解决问题
2. **多种思路**：同一问题可以用多种数学和编程技巧解决
3. **效率考虑**：虽然时间复杂度相同，但实际运行效率可能不同
4. **代码简洁性**：Counter等库函数可以让代码更简洁

## 常见错误

1. **忽略字符编码**：没有正确使用ord()和chr()函数
2. **边界情况遗漏**：没有考虑空字符串的情况
3. **算法理解错误**：不理解异或运算的数学性质
4. **效率误解**：认为使用库函数一定更慢

## 算法扩展

1. **如果有多个不同字符怎么办？** - 需要修改算法逻辑
2. **如果字符可能重复多次？** - 异或方法仍然适用
3. **如果是Unicode字符？** - ord()和chr()仍然有效

## 相关题目

- [136. Single Number](136_single_number.md) - 只出现一次的数字
- [268. Missing Number](268_missing_number.md) - 丢失的数字
- [287. Find the Duplicate Number](287_find_the_duplicate_number.md) - 寻找重复数

这道题展示了异或运算在算法中的巧妙应用，是位运算解决实际问题的经典例子。
